# QSlice: Quantum Program Slicing via Quantum Dependency Graphs

QSlice is an **experimental quantum program slicing framework** built on top of
**QStatic** (https://github.com/srcML/QStatic).

It enables dependency-aware analysis of quantum programs by constructing a
**Quantum Dependency Graph (QDG)** and extracting **forward and backward slices**
with respect to quantum operations.

QSlice is intended for **research and prototyping** in quantum program analysis,
change impact analysis, and program comprehension.

---

## Key Capabilities

- **Quantum Dependency Graph (QDG)**
  - Nodes represent quantum operations (gate calls, control events, measurements)
  - Edges capture:
    - Wire dependencies (sequential operations on the same qubit)
    - Entanglement dependencies (multi-qubit gates such as `cx`)

- **Forward and Backward Quantum Slicing**
  - Slice with respect to a qubit, program point (line number), or operation

- **Graph-based Visualization**
  - Full QDG visualization
  - Slice-aware highlighting using Graphviz

> ⚠️ **Note**  
> QStatic and srcML support for OpenQASM is still evolving.
> Some XML files are manually annotated with position (`pos`) attributes.

---
## Quantum Dependency Graph Example

![Quantum Dependency Graph (QDG) example](images/qdg.png)

## Slice Examples

Backward slice (criterion: `q3` at line 11):

![Backward slice example](images/qdg_backward.png)

Forward slice (criterion: `q2` at line 10):

![Forward slice example](images/qdg_forward.png)

---
## Requirements

- Python 3.9+
- srcML
- Graphviz (`dot`)

### macOS installation
    brew install srcml graphviz

---

## Repository Structure

    .
    ├── qslice.py               QDG construction and slicing logic
    ├── parser.py               QStatic parser (from QStatic)
    ├── examples/
    │   ├── hadamard_cnot.qasm
    │   ├── hadamard_cnot.qasm.xml
    │   ├── chain3.qasm
    │   └── chain3.qasm.xml
    ├── out.json                Generated by parser.py
    ├── slice.json              Generated slice result
    └── qdg.dot / qdg.png       QDG visualization

---

## Quick Start (5 Minutes)

### 1) Parse OpenQASM and generate intermediate representation

    python3 parser.py examples/chain3.qasm.xml

This produces:
    out.json

---

### 2) Build the Quantum Dependency Graph (QDG)

    python3 qslice.py --export-dot

Render:
    dot -Tpng -Gdpi=300 qdg.dot -o qdg.png
    open qdg.png

---

### 3) Compute a Backward Slice

Example: backward slice for qubit `q3` at line 11

    python3 qslice.py \
      --qubit q3 \
      --line 11 \
      --direction backward \
      --export-dot \
      --dot-highlight-slice

Render:
    dot -Tpng -Gdpi=300 qdg.dot -o qdg_backward.png
    open qdg_backward.png

This slice includes all quantum operations that **can influence** the slicing criterion.

---

### 4) Compute a Forward Slice

Example: forward slice from qubit `q2` at line 10

    python3 qslice.py \
      --qubit q2 \
      --line 10 \
      --direction forward \
      --export-dot \
      --dot-highlight-slice

Render:
    dot -Tpng -Gdpi=300 qdg.dot -o qdg_forward.png
    open qdg_forward.png

This slice includes all operations that **are influenced by** the slicing criterion.

---

## Printing a Slice in QASM-like Form

After slicing, `slice.json` contains the extracted slice.

    python3 - <<'PY'
    import json
    from collections import defaultdict

    d=json.load(open("slice.json"))
    by_line=defaultdict(list)
    for a in d["slice_actions"]:
        by_line[a["line"]].append(a)

    for line in sorted(by_line):
        acts=by_line[line]
        ctrl = next((x for x in acts if x["action"]=="ctrl"), None)
        targ = next((x for x in acts if x["action"]=="ctrl-gate-call"), None)
        if ctrl and targ:
            print(f"line {line}: cx {ctrl['qubit']}, {targ['qubit']};")
        else:
            for a in acts:
                if a["action"]=="gate-call":
                    print(f"line {line}: {a['gate']} {a['qubit']};")
                elif a["action"]=="measure":
                    print(f"line {line}: measure {a['qubit']} -> {a.get('store','?')};")
    PY

---

## Conceptual Model

- Nodes: quantum operations (gate calls, control events, measurements)
- Wire edges: sequential dependencies on the same qubit
- Entanglement edges: multi-qubit gate coupling (e.g., `cx`)
- Backward slice: operations that can influence a slicing criterion
- Forward slice: operations that are influenced by a slicing criterion

---

## Status and Scope

QSlice is a **research prototype** intended for:

- exploring quantum slicing semantics
- studying dependency propagation via entanglement
- serving as a foundation for quantum change impact analysis (CIA)

It is **not** a production compiler or simulator.

---

## Relationship to QStatic

QSlice **builds on top of QStatic**:
- QStatic provides parsing and low-level action extraction
- QSlice introduces dependency modeling, slicing, and visualization

QSlice does **not replace** QStatic — it extends it.
